---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# ABAP

<!-- badges: start -->
[![R-CMD-check](https://github.com/AfricaBirdData/ABAP/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/AfricaBirdData/ABAP/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

This packages provides functionality to access, download, and manipulate data from
the [African Bird Atlas Project](http://www.birdmap.africa/). 

The objective is to make these data more accessible and easier to analysis, and
eventually make our analyses more reproducible.

There is another package named [`CWAC`](https://github.com/AfricaBirdData/CWAC)
that provides similar functionality, but now to download count data from the
Coordinated Waterbird Counts project. In addition, there is a companion package
the [`ABDtools`](https://github.com/AfricaBirdData/ABDtools) package, which adds
the functionality necessary to annotate data with environmental information from the 
[Google Earth Engine data catalog](https://developers.google.com/earth-engine/datasets).


## INSTRUCTIONS TO INSTALL

To install from GitHub using the [remotes](https://github.com/r-lib/remotes) package, run:

```{r, eval=FALSE}
install.packages("remotes")
remotes::install_github("AfricaBirdData/ABAP")
```

## DOWNLOAD ABAP DATA

A typical workflow entails defining a region and a species of interest,
e.g. say we are interested in the occupancy of the African Black Duck in
the North West province of South Africa:

First find the ABAP code for the species (SAFRING code):

```{r, eval=FALSE}
library(ABAP)
library(sf)
library(dplyr, warn.conflicts = FALSE)

# We can search for all duck species
ducks <- searchAbapSpecies("Duck")

# Then we can extract the code we are interested in
ducks[ducks$Common_species == "African Black", "SAFRING_No"]

```

With our code (95) we can download the data recorded for the region of interest:

```{r eval=FALSE}
my_det_data <- getAbapData(.spp_code = 95, .region_type = "province", .region = "North West")
```

Note the trailing dots in the argument names. This makes it easier to incorporate
this function into other larger functions and workflows.

We may be interested in detection data in a set of pentads that do not
correspond to any particular region. Although getAbapData allows you to download
data from any one pentad, it is not advised to use this functionality to loop
over a set of pentads (unless it is a small set). this is because the algorithm
will create a query for each pentad! Resulting in a very slow process. The 
easiest and fastest way to obtain these data is to download a larger region that
contains our pentads and then filter only those we are interested in.

For demonstration purposes let's subset ten random pentads in the North West 
province using the data we just downloaded and download Black Duck data for them.
This doesn't make any sense, but hopefully shows the point.

```{r eval=FALSE}
set.seed(8476)

pentads_sel <- unique(my_det_data$Pentad) %>% 
  sample(10)

# We can now subset those pentads from the original data
det_data_sel <- my_det_data[my_det_data$Pentad %in% pentads_sel,]

```

To illustrate the entire workflow with [dplyr](https://dplyr.tidyverse.org/), 
we will use the same selection of pentads.

```{r eval=FALSE}

# Find species code
my_det_data <- searchAbapSpecies("Duck") %>% 
  filter(Common_species == "African Black") %>% 
  pull(SAFRING_No) %>% 
  # Download ABAP data for the whole North West province
  getAbapData(.region_type = "province", .region = "North West") %>% 
  # Filter pentads of interest  
  filter(Pentad %in% pentads_sel)

```

Finally, one can download ABAP pentads of a region of interest in
[sf](https://r-spatial.github.io/sf/) format (POLYGON).

```{r eval=FALSE}
mypentads <- getRegionPentads(.region_type = "province",
                              .region = "North West")
```


## SOME USE CASES

### Download one species data for a subregion

### Download all species data for a subregion


## INSTRUCTIONS TO CONTRIBUTE CODE

First clone the repository to your local machine:

- In RStudio, create a new project
- In the ‘Create project’ menu, select ‘Version Control’/‘Git’
- Copy the repository URL (click on the ‘Code’ green button and
        copy the link)
- Choose the appropriate directory and ‘Create project’
- Remember to pull the latest version regularly

For site owners:

There is the danger of multiple people working simultaneously on the
project code. If you make changes locally on your computer and, before
you push your changes, others push theirs, there might be conflicts.
This is because the HEAD pointer in the main branch has moved since you
started working.

To deal with these lurking issues, I would suggest opening and working
on a topic branch. This is a just a regular branch that has a short
lifespan. In steps:

-   Open a branch at your local machine
-   Push to the remote repo
-   Make your changes in your local machine
-   Commit and push to remote
-   Create pull request:
    -   In the GitHub repo you will now see an option that notifies of
        changes in a branch: click compare and pull request.
-   Delete the branch. When you are finished, you will have to delete the new
    branch in the remote repo (GitHub) and also in your local machine. In your
    local machine you have to use Git directly, because apparently RStudio 
    doesn´t do it:
    -   In your local machine, change to master branch.
    -   Either use the Git GUI (go to branches/delete/select
        branch/push).
    -   Or use the console typing ‘git branch -d your\_branch\_name’.
    -   It might also be necessary to prune remote branches with 'git remote prune origin'.

Opening branches is quick and easy, so there is no harm in opening
multiple branches a day. However, it is important to merge and delete
them often to keep things tidy. Git provides functionality to deal with
conflicting branches. More about branches here:

<https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell>

Another idea is to use the ‘issues’ tab that you find in the project
header. There, we can identify issues with the package, assign tasks and
warn other contributors that we will be working on the code.
